/**
 * Face API - V1.0
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import request = require('request');
import http = require('http');
import Promise = require('bluebird');

let defaultBasePath = 'https://westus.api.cognitive.microsoft.com/face/v1.0';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */


export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: request.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(requestOptions: request.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string;

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: request.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string;

    applyToRequest(requestOptions: request.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(_: request.Options): void {
        // Do nothing
    }
}

export enum DefaultApiApiKeys {
}

export class DefaultApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: DefaultApiApiKeys, value: string) {
        this.authentications[DefaultApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * Detect human faces in an image and returns face locations, and optionally with faceIds, landmarks, and attributes.    &lt;ul&gt;  &lt;li&gt;Optional parameters for returning faceId, landmarks, and attributes. Attributes include age, gender, smile intensity, facial hair, head pose and glasses. faceId is for other APIs use including  &lt;a href&#x3D;\&quot;/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395239\&quot;&gt;Face - Identify&lt;/a&gt;,  &lt;a href&#x3D;\&quot;/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039523a\&quot;&gt;Face - Verify&lt;/a&gt;, and  &lt;a href&#x3D;\&quot;/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395237\&quot;&gt;Face - Find Similar&lt;/a&gt;.  The faceId will expire in 24 hours after detection call.&lt;/li&gt;  &lt;ul&gt;  &lt;li&gt;JPEG, PNG, GIF(the first frame), and BMP are supported. The image file size should be larger than or equal to 1KB but no larger than 4MB.&lt;/li&gt;  &lt;li&gt;The detectable face size is between 36x36 to 4096x4096 pixels. The faces out of this range will not be detected.&lt;/li&gt;  &lt;li&gt;A maximum of 64 faces could be returned for an image. The returned faces are ranked by face rectangle size in descending order.&lt;/li&gt;  &lt;li&gt;Some faces may not be detected for technical challenges, e.g. very large face angles (head-pose) or large occlusion. Frontal and near-frontal faces have the best results.&lt;/li&gt;  &lt;li&gt;Attributes (age, gender, headPose, smile, facialHair, and glasses) are still experimental and may not be very accurate. HeadPose&#39;s pitch value is a reserved field and will always return 0.&lt;/li&gt;  &lt;/ul&gt;  &lt;/li&gt;  &lt;/ul&gt;  &lt;h4&gt;Http Method&lt;/h4&gt;  POST
     * @param returnFaceId Return faceIds of the detected faces or not. The default value is true. 
     * @param returnFaceLandmarks Return face landmarks of the detected faces or not. The default value is false. 
     * @param returnFaceAttributes Analyze and return the one or more specified face attributes in the comma-separated string like \&quot;returnFaceAttributes&#x3D;age,gender\&quot;. Supported face attributes include age, gender, headPose, smile, facialHair, and glasses. Note that each face attribute analysis has additional computational and time cost.
     * @param subscriptionKey subscription key in url
     * @param ocpApimSubscriptionKey subscription key in header
     */
    public faceDetect (returnFaceId?: boolean, returnFaceLandmarks?: boolean, returnFaceAttributes?: string, subscriptionKey?: string, ocpApimSubscriptionKey?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/detect';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (returnFaceId !== undefined) {
            queryParameters['returnFaceId'] = returnFaceId;
        }

        if (returnFaceLandmarks !== undefined) {
            queryParameters['returnFaceLandmarks'] = returnFaceLandmarks;
        }

        if (returnFaceAttributes !== undefined) {
            queryParameters['returnFaceAttributes'] = returnFaceAttributes;
        }

        if (subscriptionKey !== undefined) {
            queryParameters['subscription-key'] = subscriptionKey;
        }

        headerParams['Ocp-Apim-Subscription-Key'] = ocpApimSubscriptionKey;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     *     Given query face&#39;s faceId, to search the similar-looking faces from a faceId array or a faceListId. faceId array contains the faces created by &lt;a href&#x3D;\&quot;/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236\&quot;&gt;Face - Detect&lt;/a&gt;, which will expire in 24 hours after creation. While \&quot;faceListId\&quot; is created by &lt;a href&#x3D;\&quot;/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039524b\&quot;&gt;Face List - Create a Face List&lt;/a&gt; containing persistedFaceIds that will not expire. Depending on the input the returned similar faces list contains faceIds or persistedFaceIds ranked by similarity.    &lt;br/&gt;&lt;br/&gt;  Find similar has two working modes, \&quot;matchPerson\&quot; and \&quot;matchFace\&quot;. \&quot;matchPerson\&quot; is the default mode that it tries to find faces of the same person as possible by using internal same-person thresholds. It is useful to find a known person&#39;s other photos. Note that an empty list will be returned if no faces pass the internal thresholds.  \&quot;matchFace\&quot; mode ignores same-person thresholds and returns ranked similar faces anyway, even the similarity is low. It can be used in the cases like searching celebrity-looking faces.  &lt;h4&gt;Http Method&lt;/h4&gt;  POST    
     * @param subscriptionKey subscription key in url
     * @param ocpApimSubscriptionKey subscription key in header
     */
    public faceFindSimilar (subscriptionKey?: string, ocpApimSubscriptionKey?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/findsimilars';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (subscriptionKey !== undefined) {
            queryParameters['subscription-key'] = subscriptionKey;
        }

        headerParams['Ocp-Apim-Subscription-Key'] = ocpApimSubscriptionKey;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     *   Divide candidate faces into groups based on face similarity.  &lt;br/&gt;  &lt;ul&gt;  &lt;li&gt;The output is one or more disjointed face groups and a messyGroup. A face group contains faces  that have similar looking, often of the same person. Face groups are ranked by  group size, i.e. number of faces. Notice that faces belonging to a same person might be split into several groups in the result.  &lt;/li&gt;  &lt;li&gt;MessyGroup is a special face group containing faces that cannot find any similar counterpart face from original faces. The messyGroup will not appear in the result if all faces  found their counterparts.&lt;/li&gt;  &lt;li&gt;Group API needs at least 2 candidate faces and 1000 at most. We suggest to try &lt;a href&#x3D;\&quot;/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039523a\&quot;&gt;Face - Verify&lt;/a&gt; when you only have 2 candidate faces.&lt;/li&gt;  &lt;/ul&gt;  &lt;h4&gt;Http Method&lt;/h4&gt;  POST    
     * @param subscriptionKey subscription key in url
     * @param ocpApimSubscriptionKey subscription key in header
     */
    public faceGroup (subscriptionKey?: string, ocpApimSubscriptionKey?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/group';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (subscriptionKey !== undefined) {
            queryParameters['subscription-key'] = subscriptionKey;
        }

        headerParams['Ocp-Apim-Subscription-Key'] = ocpApimSubscriptionKey;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     *   Identify unknown faces from a person group.  &lt;br/&gt;&lt;br/&gt;  For each face in the faceIds array,  Face Identify will compute similarities between the query face and all the faces in the person group (given by personGroupId),  and returns candidate person(s) for that face ranked by similarity confidence.  The person group should be trained to make it ready for identification. See more in &lt;a href&#x3D;\&quot;/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395249\&quot;&gt;Person Group - Train Person Group&lt;/a&gt;.  &lt;br/&gt;&lt;br/&gt;  Remarks:  &lt;ul&gt;  &lt;li&gt;The algorithm allows more than one face to be identified independently at the same request, but the no more than 10 faces.&lt;/li&gt;  &lt;li&gt;Each person in the person group could have more than one face, but no more than 248 faces.&lt;/li&gt;  &lt;li&gt;Identification works well for frontal faces and near-frontal faces.&lt;/li&gt;  &lt;li&gt;Number of candidates returned is restricted by maxNumOfCandidatesReturned and confidenceThreshold. If no person is identified, the candidate returned will be an empty array.&lt;/li&gt;  &lt;li&gt;Try &lt;a href&#x3D;\&quot;/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395237\&quot;&gt;Face - Find Similar&lt;/a&gt; when you need to identify similar faces from a face list instead of a person group.&lt;/li&gt;  &lt;/ul&gt;  &lt;h4&gt;Http Method&lt;/h4&gt;  POST    
     * @param subscriptionKey subscription key in url
     * @param ocpApimSubscriptionKey subscription key in header
     */
    public faceIdentify (subscriptionKey?: string, ocpApimSubscriptionKey?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/identify';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (subscriptionKey !== undefined) {
            queryParameters['subscription-key'] = subscriptionKey;
        }

        headerParams['Ocp-Apim-Subscription-Key'] = ocpApimSubscriptionKey;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * &lt;p&gt;Add a face to a face list. The input face is specified as an image with a targetFace rectangle.  It returns a persistedFaceId representing the added face, and persistedFaceId will not expire. Note persistedFaceId is different from faceId which represents the detected face by &lt;a href&#x3D;\&quot;/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236\&quot;&gt;Face - Detect&lt;/a&gt;.  &lt;ul&gt;  &lt;li&gt;The persistedFaceId of face list is used in &lt;a href&#x3D;\&quot;/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395251\&quot;&gt;Face List - Delete a Face from a Face List&lt;/a&gt; to remove face from a face list, or the output JSON of  &lt;a href&#x3D;\&quot;/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395237\&quot;&gt;Face - Find Similar&lt;/a&gt;   &lt;/li&gt;  &lt;li&gt;JPEG, PNG, GIF(the first frame), and BMP are supported. The image file size should be larger than or equal to 1KB but no larger than 4MB.&lt;/li&gt;  &lt;li&gt;The detectable face size is between 36x36 to 4096x4096 pixels. The faces out of this range will not be detected.&lt;/li&gt;  &lt;li&gt;Rectangle specified by targetFace should contain exactly one face. Zero or multiple faces will be regarded as an error. Out of detectable face size, large head-pose, or very large occlusions will also result in fail to add a person face.&lt;/li&gt;  &lt;li&gt;The given rectangle specifies both face location and face size at the same time. There is no guarantee of correct result if you are using rectangle which are not returned from &lt;a href&#x3D;\&quot;/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236\&quot;&gt;Face - Detect&lt;/a&gt;.  &lt;/li&gt;  &lt;/ul&gt;  &lt;p&gt;  Face list is a group of faces, and these faces will not expire. Face list is used as a parameter of source faces in  &lt;a href&#x3D;\&quot;/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395237\&quot;&gt;Face - Find Similar&lt;/a&gt;.  Face List is useful when to find similar faces in a fixed face set very often, e.g. to find a similar face in a face list of celebrities, friends, or family members.&lt;/p&gt;  &lt;p&gt;  A face list can have a maximum of 1000 faces.  &lt;/p&gt;  &lt;h4&gt;Http Method&lt;/h4&gt;  POST
     * @param faceListId Valid character is letter in lower case or digit or &#39;-&#39; or &#39;_&#39;, maximum length is 64.
     * @param userData User-specified data about the face list for any purpose. The  maximum length is 1KB.
     * @param targetFace A face rectangle to specify the target face to be added into the face list, in the format of \&quot;targetFace&#x3D;left,top,width,height\&quot;. E.g. \&quot;targetFace&#x3D;10,10,100,100\&quot;. If there is more than one face in the image, targetFace is required to specify which face to add. No targetFace means there is only one face detected in the entire image.
     * @param subscriptionKey subscription key in url
     * @param ocpApimSubscriptionKey subscription key in header
     */
    public faceListAddAFaceToAFaceList (faceListId: string, userData?: string, targetFace?: string, subscriptionKey?: string, ocpApimSubscriptionKey?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/facelists/{faceListId}/persistedFaces'
            .replace('{' + 'faceListId' + '}', String(faceListId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'faceListId' is not null or undefined
        if (faceListId === null || faceListId === undefined) {
            throw new Error('Required parameter faceListId was null or undefined when calling faceListAddAFaceToAFaceList.');
        }

        if (userData !== undefined) {
            queryParameters['userData'] = userData;
        }

        if (targetFace !== undefined) {
            queryParameters['targetFace'] = targetFace;
        }

        if (subscriptionKey !== undefined) {
            queryParameters['subscription-key'] = subscriptionKey;
        }

        headerParams['Ocp-Apim-Subscription-Key'] = ocpApimSubscriptionKey;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     *   &lt;p&gt;Create an empty face list with user-specified faceListId, name and an optional userData. Up to 64 face lists are allowed to exist in one subscription.&lt;/p&gt;  &lt;p&gt;  Face list is a group of faces, and these faces will not expire. Face list is used as a parameter of source faces in  &lt;a href&#x3D;\&quot;/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395237\&quot;&gt;Face - Find Similar&lt;/a&gt;.  Face List is useful when to find similar faces in a fixed face set very often, e.g. to find a similar face in a face list of celebrities, friends, or family members.  &lt;/p&gt;  &lt;p&gt;A face list can have a maximum of 1000 faces.&lt;/p&gt;  &lt;h4&gt;Http Method&lt;/h4&gt;  PUT    
     * @param faceListId Valid character is letter in lower case or digit or &#39;-&#39; or &#39;_&#39;, maximum length is 64.         
     * @param subscriptionKey subscription key in url
     * @param ocpApimSubscriptionKey subscription key in header
     */
    public faceListCreateAFaceList (faceListId: string, subscriptionKey?: string, ocpApimSubscriptionKey?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/facelists/{faceListId}'
            .replace('{' + 'faceListId' + '}', String(faceListId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'faceListId' is not null or undefined
        if (faceListId === null || faceListId === undefined) {
            throw new Error('Required parameter faceListId was null or undefined when calling faceListCreateAFaceList.');
        }

        if (subscriptionKey !== undefined) {
            queryParameters['subscription-key'] = subscriptionKey;
        }

        headerParams['Ocp-Apim-Subscription-Key'] = ocpApimSubscriptionKey;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     *   Delete an existing face from a face list (given by a persisitedFaceId and a faceListId). Persisted image related to the face will also be deleted.  &lt;h4&gt;Http Method&lt;/h4&gt;  DELETE    
     * @param faceListId faceListId of an existing face list. Valid character is letter in lower case or digit or &#39;-&#39; or &#39;_&#39;, maximum length is 64.
     * @param persistedFaceId persistedFaceId of an existing face. Valid character is letter in lower case or digit or &#39;-&#39; or &#39;_&#39;, maximum length is 64.
     * @param subscriptionKey subscription key in url
     * @param ocpApimSubscriptionKey subscription key in header
     */
    public faceListDeleteAFaceFromAFaceList (faceListId: string, persistedFaceId: string, subscriptionKey?: string, ocpApimSubscriptionKey?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/facelists/{faceListId}/persistedFaces/{persistedFaceId}'
            .replace('{' + 'faceListId' + '}', String(faceListId))
            .replace('{' + 'persistedFaceId' + '}', String(persistedFaceId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'faceListId' is not null or undefined
        if (faceListId === null || faceListId === undefined) {
            throw new Error('Required parameter faceListId was null or undefined when calling faceListDeleteAFaceFromAFaceList.');
        }

        // verify required parameter 'persistedFaceId' is not null or undefined
        if (persistedFaceId === null || persistedFaceId === undefined) {
            throw new Error('Required parameter persistedFaceId was null or undefined when calling faceListDeleteAFaceFromAFaceList.');
        }

        if (subscriptionKey !== undefined) {
            queryParameters['subscription-key'] = subscriptionKey;
        }

        headerParams['Ocp-Apim-Subscription-Key'] = ocpApimSubscriptionKey;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     *   Delete an existing face list according to faceListId. Persisted face images in the face list will also be deleted.  &lt;h4&gt;Http Method&lt;/h4&gt;  DELETE    
     * @param faceListId Valid character is letter in lower case or digit or &#39;-&#39; or &#39;_&#39;, maximum length is 64.
     * @param subscriptionKey subscription key in url
     * @param ocpApimSubscriptionKey subscription key in header
     */
    public faceListDeleteAFaceList (faceListId: string, subscriptionKey?: string, ocpApimSubscriptionKey?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/facelists/{faceListId}'
            .replace('{' + 'faceListId' + '}', String(faceListId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'faceListId' is not null or undefined
        if (faceListId === null || faceListId === undefined) {
            throw new Error('Required parameter faceListId was null or undefined when calling faceListDeleteAFaceList.');
        }

        if (subscriptionKey !== undefined) {
            queryParameters['subscription-key'] = subscriptionKey;
        }

        headerParams['Ocp-Apim-Subscription-Key'] = ocpApimSubscriptionKey;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     *   Retrieve a face list&#39;s information, including faceListId, name, userData and faces in the face list. Face list simply represents a list of faces, and could be treated as a searchable data source in  &lt;a href&#x3D;\&quot;/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395237\&quot;&gt;Face - Find Similar&lt;/a&gt;.  &lt;h4&gt;Http Method&lt;/h4&gt;  GET    
     * @param faceListId Valid character is letter in lower case or digit or &#39;-&#39; or &#39;_&#39;, maximum length is 64.
     * @param subscriptionKey subscription key in url
     * @param ocpApimSubscriptionKey subscription key in header
     */
    public faceListGetAFaceList (faceListId: string, subscriptionKey?: string, ocpApimSubscriptionKey?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/facelists/{faceListId}'
            .replace('{' + 'faceListId' + '}', String(faceListId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'faceListId' is not null or undefined
        if (faceListId === null || faceListId === undefined) {
            throw new Error('Required parameter faceListId was null or undefined when calling faceListGetAFaceList.');
        }

        if (subscriptionKey !== undefined) {
            queryParameters['subscription-key'] = subscriptionKey;
        }

        headerParams['Ocp-Apim-Subscription-Key'] = ocpApimSubscriptionKey;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     *   Retrieve information about all existing face lists. Only faceListId, name and userData will be returned. Try &lt;a href&#x3D;\&quot;/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039524c\&quot;&gt;Face List - Get a Face List&lt;/a&gt; to retrieve face information inside faceList.  &lt;h4&gt;Http Method&lt;/h4&gt;  GET    
     * @param subscriptionKey subscription key in url
     * @param ocpApimSubscriptionKey subscription key in header
     */
    public faceListListFaceLists (subscriptionKey?: string, ocpApimSubscriptionKey?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/facelists';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (subscriptionKey !== undefined) {
            queryParameters['subscription-key'] = subscriptionKey;
        }

        headerParams['Ocp-Apim-Subscription-Key'] = ocpApimSubscriptionKey;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     *   Update information of a face list, including name and userData. Face List simply represents a list of persisted faces, and could be treated as a searchable data source in  &lt;a href&#x3D;\&quot;/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395237\&quot;&gt;Face - Find Similar&lt;/a&gt;.  &lt;h4&gt;Http Method&lt;/h4&gt;  PATCH    
     * @param faceListId Valid character is letter in lower case or digit or &#39;-&#39; or &#39;_&#39;, maximum length is 64.
     * @param subscriptionKey subscription key in url
     * @param ocpApimSubscriptionKey subscription key in header
     */
    public faceListUpdateAFaceList (faceListId: string, subscriptionKey?: string, ocpApimSubscriptionKey?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/facelists/{faceListId}'
            .replace('{' + 'faceListId' + '}', String(faceListId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'faceListId' is not null or undefined
        if (faceListId === null || faceListId === undefined) {
            throw new Error('Required parameter faceListId was null or undefined when calling faceListUpdateAFaceList.');
        }

        if (subscriptionKey !== undefined) {
            queryParameters['subscription-key'] = subscriptionKey;
        }

        headerParams['Ocp-Apim-Subscription-Key'] = ocpApimSubscriptionKey;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     *   Verify whether two faces belong to a same person or whether one face belongs to a person.  &lt;br/&gt;&lt;br/&gt;  Remarks:  &lt;ul&gt;  &lt;li&gt;This API works well for frontal and near-frontal faces. &lt;/li&gt;  &lt;li&gt;For the scenarios that are sensitive to accuracy please make your own judgment.&lt;/li&gt;  &lt;/ul&gt;  &lt;h4&gt;Http Method&lt;/h4&gt;  POST    
     * @param subscriptionKey subscription key in url
     * @param ocpApimSubscriptionKey subscription key in header
     */
    public faceVerify (subscriptionKey?: string, ocpApimSubscriptionKey?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/verify';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (subscriptionKey !== undefined) {
            queryParameters['subscription-key'] = subscriptionKey;
        }

        headerParams['Ocp-Apim-Subscription-Key'] = ocpApimSubscriptionKey;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * &lt;p&gt;Add a representative face to a person for identification. The input face is specified as an image with a targetFace rectangle.  It returns a persistedFaceId representing the added face and this persistedFaceId will not expire. Note persistedFaceId is different from faceId which represents the detected face by &lt;a href&#x3D;\&quot;/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236\&quot;&gt;Face - Detect&lt;/a&gt;.&lt;/p&gt;  &lt;ul&gt;  &lt;li&gt;The persistedFaceId of person is used in &lt;a href&#x3D;\&quot;/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039523e\&quot;&gt;Person - Delete a Person Face&lt;/a&gt; to remove a face from a person. &lt;/li&gt;  &lt;li&gt;Each person has a maximum of 248 faces.&lt;/li&gt;  &lt;li&gt;JPEG, PNG, GIF(the first frame), and BMP are supported. The image file size should be larger than or equal to 1KB but no larger than 4MB.&lt;/li&gt;  &lt;li&gt;The detectable face size is between 36x36 to 4096x4096 pixels. The faces out of this range will not be detected.&lt;/li&gt;  &lt;li&gt;Rectangle specified by targetFace should contain exactly one face. Zero or multiple faces will be regarded as an error. Out of detectable face size, large head-pose, or very large occlusions will also result in fail to add a person face.&lt;/li&gt;  &lt;li&gt;The given rectangle specifies both face location and face size at the same time. There is no guarantee of correct result if you are using rectangle which is not returned from &lt;a href&#x3D;\&quot;/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236\&quot;&gt;Face - Detect&lt;/a&gt;.  &lt;/li&gt;  &lt;/ul&gt;  &lt;h4&gt;Http Method&lt;/h4&gt;  POST    
     * @param personGroupId Specifying the person group containing the target person.
     * @param personId Target person that the face is added to.
     * @param userData User-specified data about the target face to add for any purpose. The maximum length is 1KB. 
     * @param targetFace A face rectangle to specify the target face to be added to a person, in the format of \&quot;targetFace&#x3D;left,top,width,height\&quot;. E.g. \&quot;targetFace&#x3D;10,10,100,100\&quot;. If there is more than one face in the image, targetFace is required to specify which face to add. No targetFace means there is only one face detected in the entire image. 
     * @param subscriptionKey subscription key in url
     * @param ocpApimSubscriptionKey subscription key in header
     */
    public personAddAPersonFace (personGroupId: string, personId: string, userData?: string, targetFace?: string, subscriptionKey?: string, ocpApimSubscriptionKey?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/persongroups/{personGroupId}/persons/{personId}/persistedFaces'
            .replace('{' + 'personGroupId' + '}', String(personGroupId))
            .replace('{' + 'personId' + '}', String(personId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'personGroupId' is not null or undefined
        if (personGroupId === null || personGroupId === undefined) {
            throw new Error('Required parameter personGroupId was null or undefined when calling personAddAPersonFace.');
        }

        // verify required parameter 'personId' is not null or undefined
        if (personId === null || personId === undefined) {
            throw new Error('Required parameter personId was null or undefined when calling personAddAPersonFace.');
        }

        if (userData !== undefined) {
            queryParameters['userData'] = userData;
        }

        if (targetFace !== undefined) {
            queryParameters['targetFace'] = targetFace;
        }

        if (subscriptionKey !== undefined) {
            queryParameters['subscription-key'] = subscriptionKey;
        }

        headerParams['Ocp-Apim-Subscription-Key'] = ocpApimSubscriptionKey;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     *   Create a new person in a specified person group. A newly created person have no registered face, you can call &lt;a href&#x3D;\&quot;/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039523b  \&quot;&gt;Person - Add a Person Face&lt;/a&gt; API to add faces to the person.  &lt;br/&gt;&lt;br/&gt;  The number of persons has a subscription level limit and person group level limit. Person group level limit is 1000 for both free and paid tier subscriptions. Subscription level limit is 1000 for free tier subscription and can be greater in paid tier subscriptions.  &lt;h4&gt;Http Method&lt;/h4&gt;  POST        
     * @param personGroupId Specifying the target person group to create the person.
     * @param subscriptionKey subscription key in url
     * @param ocpApimSubscriptionKey subscription key in header
     */
    public personCreateAPerson (personGroupId: string, subscriptionKey?: string, ocpApimSubscriptionKey?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/persongroups/{personGroupId}/persons'
            .replace('{' + 'personGroupId' + '}', String(personGroupId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'personGroupId' is not null or undefined
        if (personGroupId === null || personGroupId === undefined) {
            throw new Error('Required parameter personGroupId was null or undefined when calling personCreateAPerson.');
        }

        if (subscriptionKey !== undefined) {
            queryParameters['subscription-key'] = subscriptionKey;
        }

        headerParams['Ocp-Apim-Subscription-Key'] = ocpApimSubscriptionKey;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     *   Delete an existing person from a person group. Persisted face images of the person will also be deleted.  &lt;h4&gt;Http Method&lt;/h4&gt;  DELETE    
     * @param personGroupId Specifying the person group containing the person.
     * @param personId The target personId to delete.
     * @param subscriptionKey subscription key in url
     * @param ocpApimSubscriptionKey subscription key in header
     */
    public personDeleteAPerson (personGroupId: string, personId: string, subscriptionKey?: string, ocpApimSubscriptionKey?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/persongroups/{personGroupId}/persons/{personId}'
            .replace('{' + 'personGroupId' + '}', String(personGroupId))
            .replace('{' + 'personId' + '}', String(personId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'personGroupId' is not null or undefined
        if (personGroupId === null || personGroupId === undefined) {
            throw new Error('Required parameter personGroupId was null or undefined when calling personDeleteAPerson.');
        }

        // verify required parameter 'personId' is not null or undefined
        if (personId === null || personId === undefined) {
            throw new Error('Required parameter personId was null or undefined when calling personDeleteAPerson.');
        }

        if (subscriptionKey !== undefined) {
            queryParameters['subscription-key'] = subscriptionKey;
        }

        headerParams['Ocp-Apim-Subscription-Key'] = ocpApimSubscriptionKey;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     *   Delete a face from a person. Relative image for the persisted face will also be deleted.  &lt;h4&gt;Http Method&lt;/h4&gt;  DELETE    
     * @param personGroupId Specifying the person group containing the target person.
     * @param personId Specifying the person that the target persisted face belong to.
     * @param persistedFaceId The persisted face to remove. This persistedFaceId is returned from &lt;a href&#x3D;\&quot;/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039523b\&quot;&gt;Person - Add a Person Face&lt;/a&gt;.
     * @param subscriptionKey subscription key in url
     * @param ocpApimSubscriptionKey subscription key in header
     */
    public personDeleteAPersonFace (personGroupId: string, personId: string, persistedFaceId: string, subscriptionKey?: string, ocpApimSubscriptionKey?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/persongroups/{personGroupId}/persons/{personId}/persistedFaces/{persistedFaceId}'
            .replace('{' + 'personGroupId' + '}', String(personGroupId))
            .replace('{' + 'personId' + '}', String(personId))
            .replace('{' + 'persistedFaceId' + '}', String(persistedFaceId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'personGroupId' is not null or undefined
        if (personGroupId === null || personGroupId === undefined) {
            throw new Error('Required parameter personGroupId was null or undefined when calling personDeleteAPersonFace.');
        }

        // verify required parameter 'personId' is not null or undefined
        if (personId === null || personId === undefined) {
            throw new Error('Required parameter personId was null or undefined when calling personDeleteAPersonFace.');
        }

        // verify required parameter 'persistedFaceId' is not null or undefined
        if (persistedFaceId === null || persistedFaceId === undefined) {
            throw new Error('Required parameter persistedFaceId was null or undefined when calling personDeleteAPersonFace.');
        }

        if (subscriptionKey !== undefined) {
            queryParameters['subscription-key'] = subscriptionKey;
        }

        headerParams['Ocp-Apim-Subscription-Key'] = ocpApimSubscriptionKey;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     *   Retrieve a person&#39;s information, including registered persisted faces, name and userData.  &lt;h4&gt;Http Method&lt;/h4&gt;  GET    
     * @param personGroupId Specifying the person group containing the target person.
     * @param personId Specifying the target person.
     * @param subscriptionKey subscription key in url
     * @param ocpApimSubscriptionKey subscription key in header
     */
    public personGetAPerson (personGroupId: string, personId: string, subscriptionKey?: string, ocpApimSubscriptionKey?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/persongroups/{personGroupId}/persons/{personId}'
            .replace('{' + 'personGroupId' + '}', String(personGroupId))
            .replace('{' + 'personId' + '}', String(personId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'personGroupId' is not null or undefined
        if (personGroupId === null || personGroupId === undefined) {
            throw new Error('Required parameter personGroupId was null or undefined when calling personGetAPerson.');
        }

        // verify required parameter 'personId' is not null or undefined
        if (personId === null || personId === undefined) {
            throw new Error('Required parameter personId was null or undefined when calling personGetAPerson.');
        }

        if (subscriptionKey !== undefined) {
            queryParameters['subscription-key'] = subscriptionKey;
        }

        headerParams['Ocp-Apim-Subscription-Key'] = ocpApimSubscriptionKey;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     *   Retrieve information about a persisted face (specified by persistedFaceId, personId and its belonging personGroupId).  &lt;h4&gt;Http Method&lt;/h4&gt;  GET    
     * @param personGroupId Specifying the person group containing the target person.
     * @param personId Specifying the target person that the face belongs to.
     * @param persistedFaceId The persistedFaceId of the target persisted face of the person.
     * @param subscriptionKey subscription key in url
     * @param ocpApimSubscriptionKey subscription key in header
     */
    public personGetAPersonFace (personGroupId: string, personId: string, persistedFaceId: string, subscriptionKey?: string, ocpApimSubscriptionKey?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/persongroups/{personGroupId}/persons/{personId}/persistedFaces/{persistedFaceId}'
            .replace('{' + 'personGroupId' + '}', String(personGroupId))
            .replace('{' + 'personId' + '}', String(personId))
            .replace('{' + 'persistedFaceId' + '}', String(persistedFaceId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'personGroupId' is not null or undefined
        if (personGroupId === null || personGroupId === undefined) {
            throw new Error('Required parameter personGroupId was null or undefined when calling personGetAPersonFace.');
        }

        // verify required parameter 'personId' is not null or undefined
        if (personId === null || personId === undefined) {
            throw new Error('Required parameter personId was null or undefined when calling personGetAPersonFace.');
        }

        // verify required parameter 'persistedFaceId' is not null or undefined
        if (persistedFaceId === null || persistedFaceId === undefined) {
            throw new Error('Required parameter persistedFaceId was null or undefined when calling personGetAPersonFace.');
        }

        if (subscriptionKey !== undefined) {
            queryParameters['subscription-key'] = subscriptionKey;
        }

        headerParams['Ocp-Apim-Subscription-Key'] = ocpApimSubscriptionKey;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     *   Create a new person group with specified personGroupId, name and user-provided userData.  &lt;br/&gt;&lt;br/&gt;  A person group is one of the most important parameters for the &lt;a href&#x3D;\&quot;/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395239\&quot;&gt;Face - Identify&lt;/a&gt; API. The Identify  searches person faces in a specified person group.  &lt;h4&gt;Http Method&lt;/h4&gt;  PUT    
     * @param personGroupId User-provided personGroupId as a string. The valid characters include numbers, English letters in lower case, &#39;-&#39; and &#39;_&#39;. The maximum length of the personGroupId is 64.         
     * @param subscriptionKey subscription key in url
     * @param ocpApimSubscriptionKey subscription key in header
     */
    public personGroupCreateAPersonGroup (personGroupId: string, subscriptionKey?: string, ocpApimSubscriptionKey?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/persongroups/{personGroupId}'
            .replace('{' + 'personGroupId' + '}', String(personGroupId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'personGroupId' is not null or undefined
        if (personGroupId === null || personGroupId === undefined) {
            throw new Error('Required parameter personGroupId was null or undefined when calling personGroupCreateAPersonGroup.');
        }

        if (subscriptionKey !== undefined) {
            queryParameters['subscription-key'] = subscriptionKey;
        }

        headerParams['Ocp-Apim-Subscription-Key'] = ocpApimSubscriptionKey;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     *   Delete an existing person group. Persisted face images of all people in the person group will also be deleted.  &lt;h4&gt;Http Method&lt;/h4&gt;  DELETE    
     * @param personGroupId The personGroupId of the person group to be deleted.
     * @param subscriptionKey subscription key in url
     * @param ocpApimSubscriptionKey subscription key in header
     */
    public personGroupDeleteAPersonGroup (personGroupId: string, subscriptionKey?: string, ocpApimSubscriptionKey?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/persongroups/{personGroupId}'
            .replace('{' + 'personGroupId' + '}', String(personGroupId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'personGroupId' is not null or undefined
        if (personGroupId === null || personGroupId === undefined) {
            throw new Error('Required parameter personGroupId was null or undefined when calling personGroupDeleteAPersonGroup.');
        }

        if (subscriptionKey !== undefined) {
            queryParameters['subscription-key'] = subscriptionKey;
        }

        headerParams['Ocp-Apim-Subscription-Key'] = ocpApimSubscriptionKey;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     *   Retrieve the information of a person group, including its name and userData. This API returns person group information only, use &lt;a href&#x3D;\&quot;/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395241\&quot;&gt;Person - List Persons in a Person Group&lt;/a&gt; instead to retrieve person information under the person group.  &lt;h4&gt;Http Method&lt;/h4&gt;  GET    
     * @param personGroupId personGroupId of the target person group.
     * @param subscriptionKey subscription key in url
     * @param ocpApimSubscriptionKey subscription key in header
     */
    public personGroupGetAPersonGroup (personGroupId: string, subscriptionKey?: string, ocpApimSubscriptionKey?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/persongroups/{personGroupId}'
            .replace('{' + 'personGroupId' + '}', String(personGroupId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'personGroupId' is not null or undefined
        if (personGroupId === null || personGroupId === undefined) {
            throw new Error('Required parameter personGroupId was null or undefined when calling personGroupGetAPersonGroup.');
        }

        if (subscriptionKey !== undefined) {
            queryParameters['subscription-key'] = subscriptionKey;
        }

        headerParams['Ocp-Apim-Subscription-Key'] = ocpApimSubscriptionKey;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     *   Retrieve the training status of a person group (completed or ongoing). Training can be triggered by the &lt;a href&#x3D;\&quot;/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395249\&quot;&gt;Person Group - Train Person Group&lt;/a&gt; API. The training will process for a while on the server side..  &lt;h4&gt;Http Method&lt;/h4&gt;  GET    
     * @param personGroupId personGroupId of target person group.
     * @param subscriptionKey subscription key in url
     * @param ocpApimSubscriptionKey subscription key in header
     */
    public personGroupGetPersonGroupTrainingStatus (personGroupId: string, subscriptionKey?: string, ocpApimSubscriptionKey?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/persongroups/{personGroupId}/training'
            .replace('{' + 'personGroupId' + '}', String(personGroupId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'personGroupId' is not null or undefined
        if (personGroupId === null || personGroupId === undefined) {
            throw new Error('Required parameter personGroupId was null or undefined when calling personGroupGetPersonGroupTrainingStatus.');
        }

        if (subscriptionKey !== undefined) {
            queryParameters['subscription-key'] = subscriptionKey;
        }

        headerParams['Ocp-Apim-Subscription-Key'] = ocpApimSubscriptionKey;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     *   List person groups and their information.     &lt;ul&gt;  &lt;li&gt;  Optional string parameter \&quot;start\&quot; and int parameter \&quot;top\&quot; are adopted to specify the starting point and total number of person groups to return. All of the person groups are stored in alphabetical order of personGroupId. And the list starting point is defined as the first person group whose personGroupId is greater than the \&quot;start\&quot;. Beginning from this starting point, this API returns the first \&quot;top\&quot; person groups.  &lt;ul&gt;  &lt;li&gt;  Defaults to return the first 1000 person groups, where the value of \&quot;start\&quot; is empty and \&quot;top\&quot; is 1000. Empty array returned indicates that there is no person group whose personGroupId is lager than the \&quot;start\&quot;. E.g., given two person groups: \&quot;first_group\&quot; and \&quot;second_group\&quot;, these two groups are returned with default parameter, \&quot;second_group\&quot; is returned if specify \&quot;first_group\&quot; as \&quot;start\&quot;, and if specify \&quot;second_group\&quot; as \&quot;start\&quot;, empty array is returned.  &lt;ul&gt;  &lt;li&gt;  The last personGroupId returned by current call can be used as the \&quot;start\&quot; of the next call to continuously list the person groups.  &lt;/ul&gt;  &lt;/ul&gt;  &lt;/ul&gt;  &lt;h4&gt;Http Method&lt;/h4&gt;  GET    
     * @param start List person groups from the least personGroupId greater than the \&quot;start\&quot;. It contains no more than 64 characters. Default is empty. 
     * @param top The number of person groups to list, ranging in [1, 1000]. Default is 1000. 
     * @param subscriptionKey subscription key in url
     * @param ocpApimSubscriptionKey subscription key in header
     */
    public personGroupListPersonGroups (start?: string, top?: number, subscriptionKey?: string, ocpApimSubscriptionKey?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/persongroups';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (start !== undefined) {
            queryParameters['start'] = start;
        }

        if (top !== undefined) {
            queryParameters['top'] = top;
        }

        if (subscriptionKey !== undefined) {
            queryParameters['subscription-key'] = subscriptionKey;
        }

        headerParams['Ocp-Apim-Subscription-Key'] = ocpApimSubscriptionKey;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     *   Queue a person group training task, the training task may not be started immediately.  &lt;br/&gt;&lt;br/&gt;  Any updates to person group will not take effect in &lt;a href&#x3D;\&quot;/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395239\&quot;&gt;Face - Identify&lt;/a&gt; until person group is successfully trained.  You can query the training status by calling &lt;a href&#x3D;\&quot;/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395247\&quot;&gt;Person Group - Get Person Group Training Status&lt;/a&gt; API.  &lt;h4&gt;Http Method&lt;/h4&gt;  POST    
     * @param personGroupId Target person group to be trained.
     * @param subscriptionKey subscription key in url
     * @param ocpApimSubscriptionKey subscription key in header
     */
    public personGroupTrainPersonGroup (personGroupId: string, subscriptionKey?: string, ocpApimSubscriptionKey?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/persongroups/{personGroupId}/train'
            .replace('{' + 'personGroupId' + '}', String(personGroupId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'personGroupId' is not null or undefined
        if (personGroupId === null || personGroupId === undefined) {
            throw new Error('Required parameter personGroupId was null or undefined when calling personGroupTrainPersonGroup.');
        }

        if (subscriptionKey !== undefined) {
            queryParameters['subscription-key'] = subscriptionKey;
        }

        headerParams['Ocp-Apim-Subscription-Key'] = ocpApimSubscriptionKey;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     *   Update an existing person group&#39;s display name and userData. The properties which does not appear in request body will not be updated.  &lt;h4&gt;Http Method&lt;/h4&gt;  PATCH    
     * @param personGroupId personGroupId of the person group to be updated.
     * @param subscriptionKey subscription key in url
     * @param ocpApimSubscriptionKey subscription key in header
     */
    public personGroupUpdateAPersonGroup (personGroupId: string, subscriptionKey?: string, ocpApimSubscriptionKey?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/persongroups/{personGroupId}'
            .replace('{' + 'personGroupId' + '}', String(personGroupId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'personGroupId' is not null or undefined
        if (personGroupId === null || personGroupId === undefined) {
            throw new Error('Required parameter personGroupId was null or undefined when calling personGroupUpdateAPersonGroup.');
        }

        if (subscriptionKey !== undefined) {
            queryParameters['subscription-key'] = subscriptionKey;
        }

        headerParams['Ocp-Apim-Subscription-Key'] = ocpApimSubscriptionKey;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     *   List all persons in a person group, and retrieve person information (including personId, name, userData and persistedFaceIds of registered faces of the person).  &lt;h4&gt;Http Method&lt;/h4&gt;  GET    
     * @param personGroupId personGroupId of the target person group.
     * @param subscriptionKey subscription key in url
     * @param ocpApimSubscriptionKey subscription key in header
     */
    public personListPersonsInAPersonGroup (personGroupId: string, subscriptionKey?: string, ocpApimSubscriptionKey?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/persongroups/{personGroupId}/persons'
            .replace('{' + 'personGroupId' + '}', String(personGroupId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'personGroupId' is not null or undefined
        if (personGroupId === null || personGroupId === undefined) {
            throw new Error('Required parameter personGroupId was null or undefined when calling personListPersonsInAPersonGroup.');
        }

        if (subscriptionKey !== undefined) {
            queryParameters['subscription-key'] = subscriptionKey;
        }

        headerParams['Ocp-Apim-Subscription-Key'] = ocpApimSubscriptionKey;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     *   Update name or userData of a person.  &lt;h4&gt;Http Method&lt;/h4&gt;  PATCH    
     * @param personGroupId Specifying the person group containing the target person.
     * @param personId personId of the target person.
     * @param subscriptionKey subscription key in url
     * @param ocpApimSubscriptionKey subscription key in header
     */
    public personUpdateAPerson (personGroupId: string, personId: string, subscriptionKey?: string, ocpApimSubscriptionKey?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/persongroups/{personGroupId}/persons/{personId}'
            .replace('{' + 'personGroupId' + '}', String(personGroupId))
            .replace('{' + 'personId' + '}', String(personId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'personGroupId' is not null or undefined
        if (personGroupId === null || personGroupId === undefined) {
            throw new Error('Required parameter personGroupId was null or undefined when calling personUpdateAPerson.');
        }

        // verify required parameter 'personId' is not null or undefined
        if (personId === null || personId === undefined) {
            throw new Error('Required parameter personId was null or undefined when calling personUpdateAPerson.');
        }

        if (subscriptionKey !== undefined) {
            queryParameters['subscription-key'] = subscriptionKey;
        }

        headerParams['Ocp-Apim-Subscription-Key'] = ocpApimSubscriptionKey;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     *   Update a person persisted face&#39;s userData field.  &lt;h4&gt;Http Method&lt;/h4&gt;  PATCH    
     * @param personGroupId Specifying the person group containing the target person.
     * @param personId personId of the target person.
     * @param persistedFaceId persistedFaceId of target face, which is persisted and will not expire.
     * @param subscriptionKey subscription key in url
     * @param ocpApimSubscriptionKey subscription key in header
     */
    public personUpdateAPersonFace (personGroupId: string, personId: string, persistedFaceId: string, subscriptionKey?: string, ocpApimSubscriptionKey?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/persongroups/{personGroupId}/persons/{personId}/persistedFaces/{persistedFaceId}'
            .replace('{' + 'personGroupId' + '}', String(personGroupId))
            .replace('{' + 'personId' + '}', String(personId))
            .replace('{' + 'persistedFaceId' + '}', String(persistedFaceId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'personGroupId' is not null or undefined
        if (personGroupId === null || personGroupId === undefined) {
            throw new Error('Required parameter personGroupId was null or undefined when calling personUpdateAPersonFace.');
        }

        // verify required parameter 'personId' is not null or undefined
        if (personId === null || personId === undefined) {
            throw new Error('Required parameter personId was null or undefined when calling personUpdateAPersonFace.');
        }

        // verify required parameter 'persistedFaceId' is not null or undefined
        if (persistedFaceId === null || persistedFaceId === undefined) {
            throw new Error('Required parameter persistedFaceId was null or undefined when calling personUpdateAPersonFace.');
        }

        if (subscriptionKey !== undefined) {
            queryParameters['subscription-key'] = subscriptionKey;
        }

        headerParams['Ocp-Apim-Subscription-Key'] = ocpApimSubscriptionKey;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
