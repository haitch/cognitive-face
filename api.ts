/**
 * Face API - V1.0
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import request = require('request');
import http = require('http');
import Promise = require('bluebird');

let defaultBasePath = 'https://westus.api.cognitive.microsoft.com/face/v1.0';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */

export class FaceDetectByUrlRequest {
    'url': string;
}

export class FaceIdentifyRequest {
    'personGroupId': string;
    'faceIds': Array<string>;
    'maxNumOfCandidatesReturned': number;
    'confidenceThreshold': number;
}

export class GroupFaceRequest extends Array<string> {
}

export class Person {
    'name': string;
    'userData': any;
}

export class PersonGroup {
    'name': string;
    'userData': any;
}


export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: request.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(requestOptions: request.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string;

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: request.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string;

    applyToRequest(requestOptions: request.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(_: request.Options): void {
        // Do nothing
    }
}

export enum DefaultApiApiKeys {
}

export class DefaultApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: DefaultApiApiKeys, value: string) {
        this.authentications[DefaultApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * Add a representative face to a person for identification. The input face is specified as an image with a targetFace rectangle.
     * @param personGroupId User-provided personGroupId as a string. The valid characters include numbers, English letters in lower case, &#39;-&#39; and &#39;_&#39;. The maximum length of the personGroupId is 64.
     * @param personId The target personId.
     * @param ocpApimSubscriptionKey subscription key in header
     * @param userData User-specified data about the target face to add for any purpose. The maximum length is 1KB. 
     * @param targetFace A face rectangle to specify the target face to be added to a person, in the format of \&quot;targetFace&#x3D;left,top,width,height\&quot;. E.g. \&quot;targetFace&#x3D;10,10,100,100\&quot;. If there is more than one face in the image, targetFace is required to specify which face to add. No targetFace means there is only one face detected in the entire image. 
     */
    public addPersonFace (personGroupId: string, personId: string, ocpApimSubscriptionKey: string, userData?: string, targetFace?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/persongroups/{personGroupId}/persons/{personId}/persistedFaces'
            .replace('{' + 'personGroupId' + '}', String(personGroupId))
            .replace('{' + 'personId' + '}', String(personId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'personGroupId' is not null or undefined
        if (personGroupId === null || personGroupId === undefined) {
            throw new Error('Required parameter personGroupId was null or undefined when calling addPersonFace.');
        }

        // verify required parameter 'personId' is not null or undefined
        if (personId === null || personId === undefined) {
            throw new Error('Required parameter personId was null or undefined when calling addPersonFace.');
        }

        // verify required parameter 'ocpApimSubscriptionKey' is not null or undefined
        if (ocpApimSubscriptionKey === null || ocpApimSubscriptionKey === undefined) {
            throw new Error('Required parameter ocpApimSubscriptionKey was null or undefined when calling addPersonFace.');
        }

        if (userData !== undefined) {
            queryParameters['userData'] = userData;
        }

        if (targetFace !== undefined) {
            queryParameters['targetFace'] = targetFace;
        }

        headerParams['Ocp-Apim-Subscription-Key'] = ocpApimSubscriptionKey;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Create a new person in a specified person group.
     * @param personGroupId User-provided personGroupId as a string. The valid characters include numbers, English letters in lower case, &#39;-&#39; and &#39;_&#39;. The maximum length of the personGroupId is 64.
     * @param person 
     * @param ocpApimSubscriptionKey subscription key in header
     */
    public createAPersonInGroup (personGroupId: string, person: Person, ocpApimSubscriptionKey: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/persongroups/{personGroupId}/persons'
            .replace('{' + 'personGroupId' + '}', String(personGroupId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'personGroupId' is not null or undefined
        if (personGroupId === null || personGroupId === undefined) {
            throw new Error('Required parameter personGroupId was null or undefined when calling createAPersonInGroup.');
        }

        // verify required parameter 'person' is not null or undefined
        if (person === null || person === undefined) {
            throw new Error('Required parameter person was null or undefined when calling createAPersonInGroup.');
        }

        // verify required parameter 'ocpApimSubscriptionKey' is not null or undefined
        if (ocpApimSubscriptionKey === null || ocpApimSubscriptionKey === undefined) {
            throw new Error('Required parameter ocpApimSubscriptionKey was null or undefined when calling createAPersonInGroup.');
        }

        headerParams['Ocp-Apim-Subscription-Key'] = ocpApimSubscriptionKey;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: person,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Create a new person group with specified personGroupId, name and user-provided userData.
     * @param personGroupId User-provided personGroupId as a string. The valid characters include numbers, English letters in lower case, &#39;-&#39; and &#39;_&#39;. The maximum length of the personGroupId is 64.
     * @param personGroup 
     * @param ocpApimSubscriptionKey subscription key in header
     */
    public createPersonGroup (personGroupId: string, personGroup: PersonGroup, ocpApimSubscriptionKey: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/persongroups/{personGroupId}'
            .replace('{' + 'personGroupId' + '}', String(personGroupId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'personGroupId' is not null or undefined
        if (personGroupId === null || personGroupId === undefined) {
            throw new Error('Required parameter personGroupId was null or undefined when calling createPersonGroup.');
        }

        // verify required parameter 'personGroup' is not null or undefined
        if (personGroup === null || personGroup === undefined) {
            throw new Error('Required parameter personGroup was null or undefined when calling createPersonGroup.');
        }

        // verify required parameter 'ocpApimSubscriptionKey' is not null or undefined
        if (ocpApimSubscriptionKey === null || ocpApimSubscriptionKey === undefined) {
            throw new Error('Required parameter ocpApimSubscriptionKey was null or undefined when calling createPersonGroup.');
        }

        headerParams['Ocp-Apim-Subscription-Key'] = ocpApimSubscriptionKey;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: personGroup,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Delete an existing person from a person group. Persisted face images of the person will also be deleted.
     * @param personGroupId User-provided personGroupId as a string. The valid characters include numbers, English letters in lower case, &#39;-&#39; and &#39;_&#39;. The maximum length of the personGroupId is 64.
     * @param personId The target personId.
     * @param ocpApimSubscriptionKey subscription key in header
     */
    public deleteAPerson (personGroupId: string, personId: string, ocpApimSubscriptionKey: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/persongroups/{personGroupId}/persons/{personId}'
            .replace('{' + 'personGroupId' + '}', String(personGroupId))
            .replace('{' + 'personId' + '}', String(personId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'personGroupId' is not null or undefined
        if (personGroupId === null || personGroupId === undefined) {
            throw new Error('Required parameter personGroupId was null or undefined when calling deleteAPerson.');
        }

        // verify required parameter 'personId' is not null or undefined
        if (personId === null || personId === undefined) {
            throw new Error('Required parameter personId was null or undefined when calling deleteAPerson.');
        }

        // verify required parameter 'ocpApimSubscriptionKey' is not null or undefined
        if (ocpApimSubscriptionKey === null || ocpApimSubscriptionKey === undefined) {
            throw new Error('Required parameter ocpApimSubscriptionKey was null or undefined when calling deleteAPerson.');
        }

        headerParams['Ocp-Apim-Subscription-Key'] = ocpApimSubscriptionKey;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Delete a face from a person. Relative image for the persisted face will also be deleted.
     * @param personGroupId User-provided personGroupId as a string. The valid characters include numbers, English letters in lower case, &#39;-&#39; and &#39;_&#39;. The maximum length of the personGroupId is 64.
     * @param personId The target personId.
     * @param persistedFaceId persistedFaceId of target face, which is persisted and will not expire.
     * @param ocpApimSubscriptionKey subscription key in header
     */
    public deleteAPersonFace (personGroupId: string, personId: string, persistedFaceId: string, ocpApimSubscriptionKey: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/persongroups/{personGroupId}/persons/{personId}/persistedFaces/{persistedFaceId}'
            .replace('{' + 'personGroupId' + '}', String(personGroupId))
            .replace('{' + 'personId' + '}', String(personId))
            .replace('{' + 'persistedFaceId' + '}', String(persistedFaceId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'personGroupId' is not null or undefined
        if (personGroupId === null || personGroupId === undefined) {
            throw new Error('Required parameter personGroupId was null or undefined when calling deleteAPersonFace.');
        }

        // verify required parameter 'personId' is not null or undefined
        if (personId === null || personId === undefined) {
            throw new Error('Required parameter personId was null or undefined when calling deleteAPersonFace.');
        }

        // verify required parameter 'persistedFaceId' is not null or undefined
        if (persistedFaceId === null || persistedFaceId === undefined) {
            throw new Error('Required parameter persistedFaceId was null or undefined when calling deleteAPersonFace.');
        }

        // verify required parameter 'ocpApimSubscriptionKey' is not null or undefined
        if (ocpApimSubscriptionKey === null || ocpApimSubscriptionKey === undefined) {
            throw new Error('Required parameter ocpApimSubscriptionKey was null or undefined when calling deleteAPersonFace.');
        }

        headerParams['Ocp-Apim-Subscription-Key'] = ocpApimSubscriptionKey;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * delete a person group with specified personGroupId.
     * @param personGroupId User-provided personGroupId as a string. The valid characters include numbers, English letters in lower case, &#39;-&#39; and &#39;_&#39;. The maximum length of the personGroupId is 64.
     * @param ocpApimSubscriptionKey subscription key in header
     */
    public deletePersonGroup (personGroupId: string, ocpApimSubscriptionKey: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/persongroups/{personGroupId}'
            .replace('{' + 'personGroupId' + '}', String(personGroupId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'personGroupId' is not null or undefined
        if (personGroupId === null || personGroupId === undefined) {
            throw new Error('Required parameter personGroupId was null or undefined when calling deletePersonGroup.');
        }

        // verify required parameter 'ocpApimSubscriptionKey' is not null or undefined
        if (ocpApimSubscriptionKey === null || ocpApimSubscriptionKey === undefined) {
            throw new Error('Required parameter ocpApimSubscriptionKey was null or undefined when calling deletePersonGroup.');
        }

        headerParams['Ocp-Apim-Subscription-Key'] = ocpApimSubscriptionKey;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Detect **human faces** in an image and returns face locations, and optionally with faceIds, landmarks, and attributes.
     * @param imageUrl 
     * @param ocpApimSubscriptionKey subscription key in header
     * @param returnFaceId Return faceIds of the detected faces or not. The default value is true. 
     * @param returnFaceLandmarks Return face landmarks of the detected faces or not. The default value is false. 
     */
    public faceDetect (imageUrl: FaceDetectByUrlRequest, ocpApimSubscriptionKey: string, returnFaceId?: boolean, returnFaceLandmarks?: boolean) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/detect';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'imageUrl' is not null or undefined
        if (imageUrl === null || imageUrl === undefined) {
            throw new Error('Required parameter imageUrl was null or undefined when calling faceDetect.');
        }

        // verify required parameter 'ocpApimSubscriptionKey' is not null or undefined
        if (ocpApimSubscriptionKey === null || ocpApimSubscriptionKey === undefined) {
            throw new Error('Required parameter ocpApimSubscriptionKey was null or undefined when calling faceDetect.');
        }

        if (returnFaceId !== undefined) {
            queryParameters['returnFaceId'] = returnFaceId;
        }

        if (returnFaceLandmarks !== undefined) {
            queryParameters['returnFaceLandmarks'] = returnFaceLandmarks;
        }

        headerParams['Ocp-Apim-Subscription-Key'] = ocpApimSubscriptionKey;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: imageUrl,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Retrieve a person&#39;s information, including registered persisted faces, name and userData.
     * @param personGroupId User-provided personGroupId as a string. The valid characters include numbers, English letters in lower case, &#39;-&#39; and &#39;_&#39;. The maximum length of the personGroupId is 64.
     * @param personId The target personId.
     * @param ocpApimSubscriptionKey subscription key in header
     */
    public getAPerson (personGroupId: string, personId: string, ocpApimSubscriptionKey: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/persongroups/{personGroupId}/persons/{personId}'
            .replace('{' + 'personGroupId' + '}', String(personGroupId))
            .replace('{' + 'personId' + '}', String(personId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'personGroupId' is not null or undefined
        if (personGroupId === null || personGroupId === undefined) {
            throw new Error('Required parameter personGroupId was null or undefined when calling getAPerson.');
        }

        // verify required parameter 'personId' is not null or undefined
        if (personId === null || personId === undefined) {
            throw new Error('Required parameter personId was null or undefined when calling getAPerson.');
        }

        // verify required parameter 'ocpApimSubscriptionKey' is not null or undefined
        if (ocpApimSubscriptionKey === null || ocpApimSubscriptionKey === undefined) {
            throw new Error('Required parameter ocpApimSubscriptionKey was null or undefined when calling getAPerson.');
        }

        headerParams['Ocp-Apim-Subscription-Key'] = ocpApimSubscriptionKey;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Retrieve information about a persisted face (specified by persistedFaceId, personId and its belonging personGroupId).
     * @param personGroupId User-provided personGroupId as a string. The valid characters include numbers, English letters in lower case, &#39;-&#39; and &#39;_&#39;. The maximum length of the personGroupId is 64.
     * @param personId The target personId.
     * @param persistedFaceId persistedFaceId of target face, which is persisted and will not expire.
     * @param ocpApimSubscriptionKey subscription key in header
     */
    public getAPersonFace (personGroupId: string, personId: string, persistedFaceId: string, ocpApimSubscriptionKey: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/persongroups/{personGroupId}/persons/{personId}/persistedFaces/{persistedFaceId}'
            .replace('{' + 'personGroupId' + '}', String(personGroupId))
            .replace('{' + 'personId' + '}', String(personId))
            .replace('{' + 'persistedFaceId' + '}', String(persistedFaceId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'personGroupId' is not null or undefined
        if (personGroupId === null || personGroupId === undefined) {
            throw new Error('Required parameter personGroupId was null or undefined when calling getAPersonFace.');
        }

        // verify required parameter 'personId' is not null or undefined
        if (personId === null || personId === undefined) {
            throw new Error('Required parameter personId was null or undefined when calling getAPersonFace.');
        }

        // verify required parameter 'persistedFaceId' is not null or undefined
        if (persistedFaceId === null || persistedFaceId === undefined) {
            throw new Error('Required parameter persistedFaceId was null or undefined when calling getAPersonFace.');
        }

        // verify required parameter 'ocpApimSubscriptionKey' is not null or undefined
        if (ocpApimSubscriptionKey === null || ocpApimSubscriptionKey === undefined) {
            throw new Error('Required parameter ocpApimSubscriptionKey was null or undefined when calling getAPersonFace.');
        }

        headerParams['Ocp-Apim-Subscription-Key'] = ocpApimSubscriptionKey;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Divide candidate faces into groups based on face similarity.
     * @param faceIds 
     * @param ocpApimSubscriptionKey subscription key in header
     */
    public group (faceIds: GroupFaceRequest, ocpApimSubscriptionKey: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/group';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'faceIds' is not null or undefined
        if (faceIds === null || faceIds === undefined) {
            throw new Error('Required parameter faceIds was null or undefined when calling group.');
        }

        // verify required parameter 'ocpApimSubscriptionKey' is not null or undefined
        if (ocpApimSubscriptionKey === null || ocpApimSubscriptionKey === undefined) {
            throw new Error('Required parameter ocpApimSubscriptionKey was null or undefined when calling group.');
        }

        headerParams['Ocp-Apim-Subscription-Key'] = ocpApimSubscriptionKey;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: faceIds,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Identify unknown faces from a person group.
     * @param faceIdentifyRequest 
     * @param ocpApimSubscriptionKey subscription key in header
     */
    public identify (faceIdentifyRequest: FaceIdentifyRequest, ocpApimSubscriptionKey: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/identify';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'faceIdentifyRequest' is not null or undefined
        if (faceIdentifyRequest === null || faceIdentifyRequest === undefined) {
            throw new Error('Required parameter faceIdentifyRequest was null or undefined when calling identify.');
        }

        // verify required parameter 'ocpApimSubscriptionKey' is not null or undefined
        if (ocpApimSubscriptionKey === null || ocpApimSubscriptionKey === undefined) {
            throw new Error('Required parameter ocpApimSubscriptionKey was null or undefined when calling identify.');
        }

        headerParams['Ocp-Apim-Subscription-Key'] = ocpApimSubscriptionKey;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: faceIdentifyRequest,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * List all persons in a person group, and retrieve person information (including personId, name, userData and persistedFaceIds of registered faces of the person).
     * @param personGroupId User-provided personGroupId as a string. The valid characters include numbers, English letters in lower case, &#39;-&#39; and &#39;_&#39;. The maximum length of the personGroupId is 64.
     * @param ocpApimSubscriptionKey subscription key in header
     */
    public listPersonsInPersonGroup (personGroupId: string, ocpApimSubscriptionKey: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/persongroups/{personGroupId}/persons'
            .replace('{' + 'personGroupId' + '}', String(personGroupId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'personGroupId' is not null or undefined
        if (personGroupId === null || personGroupId === undefined) {
            throw new Error('Required parameter personGroupId was null or undefined when calling listPersonsInPersonGroup.');
        }

        // verify required parameter 'ocpApimSubscriptionKey' is not null or undefined
        if (ocpApimSubscriptionKey === null || ocpApimSubscriptionKey === undefined) {
            throw new Error('Required parameter ocpApimSubscriptionKey was null or undefined when calling listPersonsInPersonGroup.');
        }

        headerParams['Ocp-Apim-Subscription-Key'] = ocpApimSubscriptionKey;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Queue a person group training task, the training task may not be started immediately.
     * @param personGroupId User-provided personGroupId as a string. The valid characters include numbers, English letters in lower case, &#39;-&#39; and &#39;_&#39;. The maximum length of the personGroupId is 64.
     * @param ocpApimSubscriptionKey subscription key in header
     */
    public trainPersonGroup (personGroupId: string, ocpApimSubscriptionKey: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/persongroups/{personGroupId}/train'
            .replace('{' + 'personGroupId' + '}', String(personGroupId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'personGroupId' is not null or undefined
        if (personGroupId === null || personGroupId === undefined) {
            throw new Error('Required parameter personGroupId was null or undefined when calling trainPersonGroup.');
        }

        // verify required parameter 'ocpApimSubscriptionKey' is not null or undefined
        if (ocpApimSubscriptionKey === null || ocpApimSubscriptionKey === undefined) {
            throw new Error('Required parameter ocpApimSubscriptionKey was null or undefined when calling trainPersonGroup.');
        }

        headerParams['Ocp-Apim-Subscription-Key'] = ocpApimSubscriptionKey;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Update name or userData of a person.
     * @param personGroupId User-provided personGroupId as a string. The valid characters include numbers, English letters in lower case, &#39;-&#39; and &#39;_&#39;. The maximum length of the personGroupId is 64.
     * @param personId The target personId.
     * @param ocpApimSubscriptionKey subscription key in header
     */
    public updateAPerson (personGroupId: string, personId: string, ocpApimSubscriptionKey: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/persongroups/{personGroupId}/persons/{personId}'
            .replace('{' + 'personGroupId' + '}', String(personGroupId))
            .replace('{' + 'personId' + '}', String(personId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'personGroupId' is not null or undefined
        if (personGroupId === null || personGroupId === undefined) {
            throw new Error('Required parameter personGroupId was null or undefined when calling updateAPerson.');
        }

        // verify required parameter 'personId' is not null or undefined
        if (personId === null || personId === undefined) {
            throw new Error('Required parameter personId was null or undefined when calling updateAPerson.');
        }

        // verify required parameter 'ocpApimSubscriptionKey' is not null or undefined
        if (ocpApimSubscriptionKey === null || ocpApimSubscriptionKey === undefined) {
            throw new Error('Required parameter ocpApimSubscriptionKey was null or undefined when calling updateAPerson.');
        }

        headerParams['Ocp-Apim-Subscription-Key'] = ocpApimSubscriptionKey;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Update a person persisted face&#39;s userData field.
     * @param personGroupId User-provided personGroupId as a string. The valid characters include numbers, English letters in lower case, &#39;-&#39; and &#39;_&#39;. The maximum length of the personGroupId is 64.
     * @param personId The target personId.
     * @param persistedFaceId persistedFaceId of target face, which is persisted and will not expire.
     * @param ocpApimSubscriptionKey subscription key in header
     */
    public updateAPersonFace (personGroupId: string, personId: string, persistedFaceId: string, ocpApimSubscriptionKey: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/persongroups/{personGroupId}/persons/{personId}/persistedFaces/{persistedFaceId}'
            .replace('{' + 'personGroupId' + '}', String(personGroupId))
            .replace('{' + 'personId' + '}', String(personId))
            .replace('{' + 'persistedFaceId' + '}', String(persistedFaceId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'personGroupId' is not null or undefined
        if (personGroupId === null || personGroupId === undefined) {
            throw new Error('Required parameter personGroupId was null or undefined when calling updateAPersonFace.');
        }

        // verify required parameter 'personId' is not null or undefined
        if (personId === null || personId === undefined) {
            throw new Error('Required parameter personId was null or undefined when calling updateAPersonFace.');
        }

        // verify required parameter 'persistedFaceId' is not null or undefined
        if (persistedFaceId === null || persistedFaceId === undefined) {
            throw new Error('Required parameter persistedFaceId was null or undefined when calling updateAPersonFace.');
        }

        // verify required parameter 'ocpApimSubscriptionKey' is not null or undefined
        if (ocpApimSubscriptionKey === null || ocpApimSubscriptionKey === undefined) {
            throw new Error('Required parameter ocpApimSubscriptionKey was null or undefined when calling updateAPersonFace.');
        }

        headerParams['Ocp-Apim-Subscription-Key'] = ocpApimSubscriptionKey;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
